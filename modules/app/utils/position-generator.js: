export class PositionGenerator {
    constructor(seed = 0x4ECDC4) {
        this.seed = seed;
        this.stats = {
            calculations: 0,
            cacheHits: 0,
            averageTime: 0
        };
    }
    
    generatePosition(entityId, options = {}) {
        const startTime = performance.now();
        
        // Используем детерминированный алгоритм на основе entityId
        const hash = this.hashEntityId(entityId);
        const random = this.seededRandom(hash);
        
        const baseRadius = options.baseRadius || 200;
        const spread = options.spread || 150;
        
        const position = {
            x: (random() - 0.5) * 1000,
            y: (random() - 0.5) * 1000,
            z: (random() - 0.5) * 500
        };
        
        // Нормализуем для орбитального распределения
        const distance = Math.sqrt(position.x ** 2 + position.y ** 2);
        const targetDistance = baseRadius + (hash % 1000) / 1000 * spread;
        
        if (distance > 0) {
            const scale = targetDistance / distance;
            position.x *= scale;
            position.y *= scale;
        }
        
        const endTime = performance.now();
        this.stats.calculations++;
        this.stats.averageTime = 
            (this.stats.averageTime * (this.stats.calculations - 1) + (endTime - startTime)) / 
            this.stats.calculations;
        
        return position;
    }
    
    hashEntityId(str) {
        let hash = 0x811c9dc5;
        for (let i = 0; i < str.length; i++) {
            hash ^= str.charCodeAt(i);
            hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
        }
        return hash >>> 0;
    }
    
    seededRandom(seed) {
        return () => {
            seed = (seed * 9301 + 49297) % 233280;
            return seed / 233280;
        };
    }
    
    getStats() {
        return { ...this.stats };
    }
}
